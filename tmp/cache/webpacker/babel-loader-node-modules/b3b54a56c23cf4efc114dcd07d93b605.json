{"ast":null,"code":"'use strict';\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar path = require('path');\n\nvar fs = require('fs');\n\nvar EventEmitter = require('events');\n\nvar cp = require('child_process');\n\nvar assert = require('assert');\n\nvar debug = require('debug')('coffee');\n\nvar spawn = require('cross-spawn');\n\nvar show = require('./show');\n\nvar Rule = require('./rule');\n\nvar ErrorRule = require('./rule_error');\n\nvar KEYS = {\n  UP: \"\\x1B[A\",\n  DOWN: \"\\x1B[B\",\n  LEFT: \"\\x1B[D\",\n  RIGHT: \"\\x1B[C\",\n  ENTER: '\\n',\n  SPACE: ' '\n};\n\nvar Coffee = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Coffee, _EventEmitter);\n\n  var _super = _createSuper(Coffee);\n\n  function Coffee() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Coffee);\n\n    _this = _super.call(this);\n    var method = options.method,\n        cmd = options.cmd,\n        args = options.args,\n        _options$opt = options.opt,\n        opt = _options$opt === void 0 ? {} : _options$opt;\n    assert(method && cmd, 'should specify method and cmd');\n    assert(!opt.cwd || fs.existsSync(opt.cwd), \"opt.cwd(\".concat(opt.cwd, \") not exists\"));\n    _this.method = method;\n    _this.cmd = cmd;\n    _this.args = args;\n    _this.opt = opt; // Only accept these type below for assertion\n\n    _this.RuleMapping = {\n      stdout: Rule,\n      stderr: Rule,\n      code: Rule,\n      error: ErrorRule\n    };\n\n    _this.restore();\n\n    _this._hookEvent();\n\n    if (process.env.COFFEE_DEBUG) {\n      _this.debug(process.env.COFFEE_DEBUG);\n    }\n\n    process.nextTick(_this._run.bind(_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  _createClass(Coffee, [{\n    key: \"_hookEvent\",\n    value: function _hookEvent() {\n      var _this2 = this;\n\n      this.on('stdout_data', function (buf) {\n        debug('output stdout `%s`', show(buf));\n        _this2._debug_stdout && process.stdout.write(buf);\n        _this2.stdout += buf;\n      });\n      this.on('stderr_data', function (buf) {\n        debug('output stderr `%s`', show(buf));\n        _this2._debug_stderr && process.stderr.write(buf);\n        _this2.stderr += buf;\n      });\n      this.on('error', function (err) {\n        _this2.error = err;\n      });\n      this.once('close', function (code) {\n        debug('output code `%s`', show(code));\n        _this2.code = code;\n        _this2.complete = true;\n\n        try {\n          var _iterator = _createForOfIteratorHelper(_this2._waitAssert),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var rule = _step.value;\n              rule.validate();\n            } // suc\n\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          var result = {\n            stdout: _this2.stdout,\n            stderr: _this2.stderr,\n            code: _this2.code,\n            error: _this2.error\n          };\n\n          _this2.emit('complete_success', result);\n\n          _this2.cb && _this2.cb(undefined, result);\n        } catch (err) {\n          _this2.emit('complete_error', err);\n\n          return _this2.cb && _this2.cb(err);\n        }\n      });\n    }\n  }, {\n    key: \"coverage\",\n    value: function coverage() {\n      // it has not been impelmented\n      // if (enable === false) {\n      //   process.env.NYC_NO_INSTRUMENT = true;\n      // }\n      return this;\n    }\n  }, {\n    key: \"debug\",\n    value: function debug(level) {\n      this._debug_stderr = false; // 0 (default) -> stdout + stderr\n      // 1 -> stdout\n      // 2 -> stderr\n\n      switch (String(level)) {\n        case '1':\n          this._debug_stdout = true;\n          break;\n\n        case '2':\n          this._debug_stderr = true;\n          break;\n\n        case 'false':\n          this._debug_stdout = false;\n          this._debug_stderr = false;\n          break;\n\n        default:\n          this._debug_stdout = true;\n          this._debug_stderr = true;\n      }\n\n      return this;\n    }\n    /**\n     * Assert type with expected value\n     *\n     * @param {String} type - assertion rule type, can be `code`,`stdout`,`stderr`,`error`.\n     * @param {Array} args - spread args, the first item used to be a test value `{Number|String|RegExp|Array} expected`\n     * @return {Coffee} return self for chain\n     */\n\n  }, {\n    key: \"expect\",\n    value: function expect(type) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      this._addAssertion({\n        type: type,\n        args: args\n      });\n\n      return this;\n    }\n    /**\n     * Assert type with not expected value, opposite assertion of `expect`.\n     *\n     * @param {String} type - assertion rule type, can be `code`,`stdout`,`stderr`,`error`.\n     * @param {Array} args - spread args, the first item used to be a test value `{Number|String|RegExp|Array} expected`\n     * @return {Coffee} return self for chain\n     */\n\n  }, {\n    key: \"notExpect\",\n    value: function notExpect(type) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      this._addAssertion({\n        type: type,\n        args: args,\n        isOpposite: true\n      });\n\n      return this;\n    }\n  }, {\n    key: \"_addAssertion\",\n    value: function _addAssertion(_ref) {\n      var type = _ref.type,\n          args = _ref.args,\n          isOpposite = _ref.isOpposite;\n      var RuleClz = this.RuleMapping[type];\n      assert(RuleClz, \"unknown rule type: \".concat(type));\n      var rule = new RuleClz({\n        ctx: this,\n        type: type,\n        expected: args[0],\n        args: args,\n        isOpposite: isOpposite\n      });\n\n      if (this.complete) {\n        rule.validate();\n      } else {\n        this._waitAssert.push(rule);\n      }\n    }\n    /**\n     * allow user to custom rule\n     * @param {String} type - rule type\n     * @param {Rule} RuleClz - custom rule class\n     * @protected\n     */\n\n  }, {\n    key: \"setRule\",\n    value: function setRule(type, RuleClz) {\n      this.RuleMapping[type] = RuleClz;\n    }\n    /**\n     * Write data to stdin of the command\n     * @param {String} input - input text\n     * @return {Coffee} return self for chain\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(input) {\n      assert(!this._isEndCalled, 'can\\'t call write after end');\n      this.stdin.push(input);\n      return this;\n    }\n    /**\n     * Write special key sequence to stdin of the command, if key name not found then write origin key.\n     * @example `.writeKey('2', 'ENTER', '3')`\n     * @param {...String} args - input key names, will join as one key\n     * @return {Coffee} return self for chain\n     */\n\n  }, {\n    key: \"writeKey\",\n    value: function writeKey() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      var input = args.map(function (x) {\n        return KEYS[x] || x;\n      });\n      return this.write(input.join(''));\n    }\n    /**\n     * whether set as prompt mode\n     *\n     * mark as `prompt`, all stdin call by `write` will wait for `prompt` event then output\n     * @param {Boolean} [enable] - default to true\n     * @return {Coffee} return self for chain\n     */\n\n  }, {\n    key: \"waitForPrompt\",\n    value: function waitForPrompt(enable) {\n      this._isWaitForPrompt = enable !== false;\n      return this;\n    }\n    /**\n     * get `end` hook\n     *\n     * @param {Function} [cb] - callback, recommended to left undefind and use promise\n     * @return {Promise} - end promise\n     */\n\n  }, {\n    key: \"end\",\n    value: function end(cb) {\n      var _this3 = this;\n\n      this.cb = cb;\n\n      if (!cb) {\n        return new Promise(function (resolve, reject) {\n          _this3.on('complete_success', resolve);\n\n          _this3.on('complete_error', reject);\n        });\n      }\n    }\n    /**\n     * inject script file for mock purpose\n     *\n     * @param {String} scriptFile - script file full path\n     * @return {Coffee} return self for chain\n     */\n\n  }, {\n    key: \"beforeScript\",\n    value: function beforeScript(scriptFile) {\n      assert(this.method === 'fork', \"can't set beforeScript on \".concat(this.method, \" process\"));\n      assert(path.isAbsolute(this.cmd), \"can't set beforeScript, \".concat(this.cmd, \" must be absolute path\"));\n      this._beforeScriptFile = scriptFile;\n      return this;\n    }\n  }, {\n    key: \"_run\",\n    value: function _run() {\n      var _this4 = this;\n\n      this._isEndCalled = true;\n\n      if (this._beforeScriptFile) {\n        var execArgv = this.opt.execArgv ? this.opt.execArgv : [].concat(process.execArgv);\n        execArgv.push('-r', this._beforeScriptFile);\n        this.opt.execArgv = execArgv;\n      }\n\n      var cmd = this.proc = run(this.method, this.cmd, this.args, this.opt);\n      cmd.stdout && cmd.stdout.on('data', this.emit.bind(this, 'stdout_data'));\n      cmd.stderr && cmd.stderr.on('data', this.emit.bind(this, 'stderr_data'));\n      cmd.once('error', this.emit.bind(this, 'error'));\n      cmd.once('close', this.emit.bind(this, 'close'));\n      process.once('exit', function (code) {\n        debug(\"coffee exit with \".concat(code));\n        cmd.kill();\n      });\n\n      if (this.stdin.length) {\n        if (this._isWaitForPrompt) {\n          // wait for message then write to stdin\n          cmd.on('message', function (msg) {\n            if (msg.type !== 'prompt' || _this4.stdin.length === 0) return;\n\n            var buf = _this4.stdin.shift();\n\n            debug('prompt stdin `%s`', show(buf));\n            cmd.stdin.write(buf);\n            if (_this4.stdin.length === 0) cmd.stdin.end();\n          });\n        } else {\n          // write immediately\n          this.stdin.forEach(function (buf) {\n            debug('input stdin `%s`', show(buf));\n            cmd.stdin.write(buf);\n          });\n          cmd.stdin.end();\n        }\n      } else {\n        // end stdin anyway\n        cmd.stdin.end();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"restore\",\n    value: function restore() {\n      // cache input for command\n      this.stdin = []; // cache output for command\n\n      this.stdout = '';\n      this.stderr = '';\n      this.code = null;\n      this.error = null; // cache expected output\n\n      this._waitAssert = [];\n      this.complete = false;\n      this._isEndCalled = false;\n      this._isWaitForPrompt = false;\n      this._debug_stdout = false;\n      this._debug_stderr = false;\n      this._isCoverage = true;\n      return this;\n    }\n  }]);\n\n  return Coffee;\n}(EventEmitter);\n\nmodule.exports = Coffee;\n\nfunction run(method, cmd, args, opt) {\n  if (!opt && args && _typeof(args) === 'object' && !Array.isArray(args)) {\n    // run(method, cmd, opt)\n    opt = args;\n    args = null;\n  }\n\n  args = args || [];\n  opt = opt || {}; // Force pipe to parent\n\n  if (method === 'fork') {\n    // Boolean If true, stdin, stdout, and stderr of the child will be piped to the parent,\n    // otherwise they will be inherited from the parent\n    opt.silent = true;\n  }\n\n  debug('child_process.%s(\"%s\", [%s], %j)', method, cmd, args, opt);\n  var handler = cp[method];\n  /* istanbul ignore next */\n\n  if (process.platform === 'win32' && method === 'spawn') handler = spawn;\n  return handler(cmd, args, opt);\n}","map":null,"metadata":{},"sourceType":"module"}